hd <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/human_development.csv", stringsAsFactors = F)
View(hd)
gii <- read.csv("http://s3.amazonaws.com/assets.datacamp.com/production/course_2218/datasets/gender_inequality.csv", stringsAsFactors = F, na.strings = "..")
View(gii)
str(hd)
dim(hd)
summary(hd)
str(gii)
#  rename the variables
colnames(hd)[3] <- 'HDI'
colnames(hd)[5] <- 'Exedu'
colnames(hd)[5] <- 'Exp.edu'
colnames(hd)[6] <-- 'Mean.edu'
colnames(hd)[6] <- 'Mean.edu'
colnames(hd)[4] <- 'Exp.lif'
colnames(hd)[7] <- 'GNI.per'
colnames(hd)[8] <- 'Rank(GNI-HDI)'
colnames(gii)[3] <- 'gii'
colnames(gii)[4] <- 'MMR'
colnames(gii)[5] <- 'ABR'
colnames(gii)[7] <- 'PopSE.Fem'
colnames(gii)[6] <- 'Percent.Rpp'
colnames(gii)[8] <- 'PopSE.M'
colnames(gii)[9] <- 'LabForR.Fam'
colnames(gii)[10] <- 'LabForR.M'
colnames(gii)[7] <- 'edu2F'
# Mutate the “Gender inequality” data and create two new variables.
library(dplyr)
mutate(gii, edu2f/m = edu2F / edu2M))
mutate(gii, edu2f/m = edu2F/edu2M)
mutate(gii, edu2f/m=edu2F/edu2M)
Gii <- mutate(gii, edu2f/m = edu2F/edu2M)
Gii <- mutate(gii, eduFM = edu2F/edu2M)
Gii <- mutate(gii, edu_FM = edu2F / edu2M)
colnames(gii)[8] <- 'edu2M'
Gii <- mutate(gii, edu_FM = edu2F / edu2M)
View(Gii)
Gii <- mutate(gii, Rfm_edu = edu2F / edu2M)
View(Gii)
colnames(gii)[9] <- 'LabF'
colnames(gii)[10] <- 'LabForR.M'
colnames(gii)[10] <- 'LabM'
Gii <- mutate(gii, Rfm_edu = edu2F / edu2M)
View(Gii)
Gii <- mutate(gii, Rfm_lab = LabF / LabM)
Gii <- mutate(gii, Rfm_edu = edu2F / edu2M)
gii <- mutate(gii, Rfm_edu = edu2F / edu2M)
Gii <- mutate(gii, Rfm_edu = edu2F / edu2M)
Gii <- mutate(gii, Rfm_edu = edu2F / edu2M, Rfm_lab = LabF / LabM)
# Join together the two datasets using the variable Country as the identifier
human <- inner_join(hd, Gii, by = "Country")
setwd('D:/github/IODS-project/data')
write.table(human, file = 'human.txt', row.names = F, sep = ',')
library(MASS)
data("Boston")
data('Boston')
# RStudio Exercise 4 - Analysis exercises
---
## 1.Create a new RMarkdown
title: "chapter4.Rmd"
output: html_document
---
## 2.Load the Boston data
* Load the Boston data from the MASS package
```{r}
install.packages("MASS")
library(MASS)
data("Boston")
```
* Explore the structure and the dimensions of the data
```{r}
str(Boston)
dim(Boston)
```
The Boston data is about housing value in suburbs of Boston. 14 Variables used to assess housing value are as following:
crim per capita crime rate by town.
zn proportion of residential land zoned for lots over 25,000 sq.ft.
indus   proportion of non-retail business acres per town.
chas    Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
nox     nitrogen oxides concentration (parts per 10 million).
rm      average number of rooms per dwelling.
age     proportion of owner-occupied units built prior to 1940.
dis     weighted mean of distances to five Boston employment centres.
rad     index of accessibility to radial highways.
tax     full-value property-tax rate per \$10,000.
ptratio pupil-teacher ratio by town.
black    1000(Bk ??? 0.63)2 where Bk is the proportion of blacks by town.
lstat    lower status of the population (percent).
medv     median value of owner-occupied homes in \$1000s.
## 3. Overview of the data
### plot matrix of the variables
```{r}
summary(Boston)
pairs(Boston[8:10])
```
### calculate the correlation matrix and round it
```{r}
library(tidyr)
cor_matrix<-cor(Boston) %>% round(2)
cor_matrix
```
*  visualize the correlation matrix
```{r}
install.packages("corrplot")
install.packages("MASS")
install.packages("MASS")
library(MASS)
data("Boston")
str(Boston)
dim(Boston)
summary(Boston)
pairs(Boston[8:10])
library(tidyr)
cor_matrix<-cor(Boston) %>% round(2)
cor_matrix
install.packages("corrplot")
corrplot(cor_matrix, method="circle", type = 'upper', cl.pos ="b", tl.pos = 'd', tl.cex = 0.6)
install.packages("corrplot")
library(corrplot)
corrplot(cor_matrix, method="circle", type = 'upper', cl.pos ="b", tl.pos = 'd', tl.cex = 0.6)
boston_scaled <- scale(Boston)
summary(boston_scaled)
class(boston_scaled)
boston_scaled <- as.data.frame(boston_scaled)
summary(boston_scaled)
summary(boston_scaled$crim)
bins <- quantile(boston_scaled$crim) %>% round(4)
bins
setwd('D:/github/IODS-project')
crime <- cut(boston_scaled$crim, breaks = bins, include.lowest = TRUE, label = c('low', 'med_low', 'med_high', 'high'))
table(crime)
boston_scaled <- dplyr::select(boston_scaled, -crim)
boston_scaled <- data.frame(boston_scaled, crime)
boston_scaled
n <- nrow(boston_scaled)
n
ind <- sample(n,  size = n * 0.8)
train <- boston_scaled[ind,]
lda.fit <- lda(crime ~ ., data = train)
lda.fit
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
heads <- coef(x)
arrows(x0 = 0, y0 = 0,
x1 = myscale * heads[,choices[1]],
y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
text(myscale * heads[,choices], labels = row.names(heads),
cex = tex, col=color, pos=3)
}
lda.arrows
classes <- as.numeric(train$crime)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
test <- boston_scaled[-ind,]
correct_classes <- test$crime
test <- dplyr::select(test, -crime)
install.packages("MASS")
library(MASS)
data("Boston")
str(Boston)
dim(Boston)
summary(Boston)
pairs(Boston[8:10])
library(tidyr)
cor_matrix<-cor(Boston) %>% round(2)
cor_matrix
install.packages("corrplot")
library(corrplot)
corrplot(cor_matrix, method="circle", type = 'upper', cl.pos ="b", tl.pos = 'd', tl.cex = 0.6)
boston_scaled <- scale(Boston)
summary(boston_scaled)
class(boston_scaled)
boston_scaled <- as.data.frame(boston_scaled)
summary(boston_scaled)
summary(boston_scaled$crim)
bins <- quantile(boston_scaled$crim) %>% round(4)
bins
getwd()
setwd('D:/github/IODS-project')
crime <- cut(boston_scaled$crim, breaks = bins, include.lowest = TRUE, label = c('low', 'med_low', 'med_high', 'high'))
table(crime)
boston_scaled <- dplyr::select(boston_scaled, -crim)
boston_scaled <- data.frame(boston_scaled, crime)
boston_scaled
n <- nrow(boston_scaled)
n
ind <- sample(n,  size = n * 0.8)
train <- boston_scaled[ind,]
lda.fit <- lda(crime ~ ., data = train)
lda.fit
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
heads <- coef(x)
arrows(x0 = 0, y0 = 0,
x1 = myscale * heads[,choices[1]],
y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
text(myscale * heads[,choices], labels = row.names(heads),
cex = tex, col=color, pos=3)
}
lda.arrows
classes <- as.numeric(train$crime)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
test <- boston_scaled[-ind,]
correct_classes <- test$crime
lda.pred <- predict(lda.fit, newdata = test)
table(correct = correct_classes, predicted = lda.pred$class)
data('Boston')
boston_scaled <- scale(Boston)
summary(boston_scaled)
dist_man <- dist(boston_scaled, method = "manhattan" )
summary(dist_man)
km <-kmeans(boston_scaled, centers = 3)
pairs(boston_scaled, col = km$cluster)
set.seed(123)
k_max <- 10
twcss <- sapply(1:k_max, function(k){kmeans(boston_scaled, k)$tot.withinss})
qplot(x = 1:k_max, y = twcss, geom = 'line')
library(ggplot2)
qplot(x = 1:k_max, y = twcss, geom = 'line')
km <-kmeans(boston_scaled, centers = 2)
pairs(boston_scaled, col = km$cluster)
pairs(boston_scaled[1:3], col = km$cluster)
pairs(boston_scaled, col = km$cluster)
View(lda.arrows)
View(lda.arrows)
data('Boston')
boston_scaled <- scale(Boston)
km <-kmeans(boston_scaled, centers = 4)
km
lda.fit <- lda(km ~ ., data = boston_scaled)
View(boston_scaled)
fit <-kmeans(boston_scaled, 4)
fit
aggregate(boston_scaled,by=list(fit$cluster),FUN=mean)
boston_scaled_1 <- data.frame(boston_scaled, fit$cluster)
boston_scaled_1
install.packages("MASS")
library(MASS)
data("Boston")
str(Boston)
dim(Boston)
summary(Boston)
pairs(Boston[8:10])
library(tidyr)
cor_matrix<-cor(Boston) %>% round(2)
cor_matrix
install.packages("corrplot")
library(corrplot)
corrplot(cor_matrix, method="circle", type = 'upper', cl.pos ="b", tl.pos = 'd', tl.cex = 0.6)
boston_scaled <- scale(Boston)
summary(boston_scaled)
class(boston_scaled)
boston_scaled <- as.data.frame(boston_scaled)
summary(boston_scaled)
summary(boston_scaled$crim)
bins <- quantile(boston_scaled$crim) %>% round(4)
bins
getwd()
setwd('D:/github/IODS-project')
crime <- cut(boston_scaled$crim, breaks = bins, include.lowest = TRUE, label = c('low', 'med_low', 'med_high', 'high'))
table(crime)
boston_scaled <- dplyr::select(boston_scaled, -crim)
boston_scaled <- data.frame(boston_scaled, crime)
boston_scaled
n <- nrow(boston_scaled)
n
ind <- sample(n,  size = n * 0.8)
train <- boston_scaled[ind,]
lda.fit <- lda(crime ~ ., data = train)
lda.fit
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
heads <- coef(x)
arrows(x0 = 0, y0 = 0,
x1 = myscale * heads[,choices[1]],
y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
text(myscale * heads[,choices], labels = row.names(heads),
cex = tex, col=color, pos=3)
}
lda.arrows
classes <- as.numeric(train$crime)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
test <- boston_scaled[-ind,]
correct_classes <- test$crime
test <- dplyr::select(test, -crime)
lda.pred <- predict(lda.fit, newdata = test)
table(correct = correct_classes, predicted = lda.pred$class)
data('Boston')
boston_scaled <- scale(Boston)
summary(boston_scaled)
dist_man <- dist(boston_scaled, method = "manhattan" )
summary(dist_man)
km <-kmeans(boston_scaled, centers = 3)
pairs(boston_scaled, col = km$cluster)
library(ggplot2)
set.seed(123)
k_max <- 10
twcss <- sapply(1:k_max, function(k){kmeans(boston_scaled, k)$tot.withinss})
qplot(x = 1:k_max, y = twcss, geom = 'line')
km <-kmeans(boston_scaled, centers = 2)
pairs(boston_scaled, col = km$cluster)
data('Boston')
boston_scaled <- scale(Boston)
fit <-kmeans(boston_scaled, 4)
fit
aggregate(boston_scaled,by=list(fit$cluster),FUN=mean)
lda.fit <- lda(fit$cluster~. data = boston_scaled_1)
lda.fit <- lda(fit$cluster ~ . data = boston_scaled_1)
lda.fit <- lda(fit$cluster ~ ., data = boston_scaled_1)
lda.fit
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
heads <- coef(x)
arrows(x0 = 0, y0 = 0,
x1 = myscale * heads[,choices[1]],
y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
text(myscale * heads[,choices], labels = row.names(heads),
cex = tex, col=color, pos=3)
}
lda.arrows
classes <- as.numeric(fit$cluster)
plot(lda.fit, dimen = 2, col = classes, pch = classes)
lda.arrows(lda.fit, myscale = 1)
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
View(lda.fit)
